# Chronarr Production Docker Compose - Auto-Configuration Enabled
#
# SIMPLIFIED SETUP: Run the one-command setup and config files are auto-generated!
#
# First-time setup:
# 1. Run: echo "DB_PASSWORD=change_me_please" > .env
# 2. Run: docker-compose up -d
# 3. Edit: .env (root directory) with secure DB_PASSWORD
# 4. Edit: ./config/.env and ./config/.env.secrets with your settings
# 5. Run: docker-compose restart
#
# IMPORTANT: DB_PASSWORD must be in TWO places:
# - Root .env (next to this file) → Used by Docker Compose to create PostgreSQL
# - ./config/.env.secrets → Used by Chronarr to connect to PostgreSQL
#
# Features:
# - Auto-generates config files from embedded examples
# - 3-container architecture (core, web, database)
# - Performance isolation between web and processing
# - Webhook responsiveness during scans
# - Professional web interface with branding

services:
  # PostgreSQL Database
  chronarr-db:
    image: postgres:15-alpine
    container_name: chronarr-db
    restart: unless-stopped
    env_file:
      - ./config/.env
      - ./config/.env.secrets
    environment:
      - POSTGRES_DB=${DB_NAME:-chronarr}
      - POSTGRES_USER=${DB_USER:-chronarr}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - TZ=${TZ:-UTC}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "${DB_EXTERNAL_PORT:-5432}:5432"  # Optional external access
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-chronarr} -d ${DB_NAME:-chronarr}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - chronarr-network

  # Chronarr Core (Processing Engine)
  chronarr:
    image: sbcrumb/chronarr:latest
    container_name: chronarr-core
    restart: unless-stopped
    env_file:
      - ./config/.env
      - ./config/.env.secrets
    environment:
      - TZ=${TZ:-UTC}
      - WEB_EXTERNAL_PORT=${WEB_EXTERNAL_PORT:-8081}
    volumes:
      # Config directory (auto-generates .env files)
      - ./config:/config
      # Media paths (adjust to your setup - these are examples)
      - /mnt/unionfs/Media/TV:/media/TV:ro
      - /mnt/unionfs/Media/Movies:/media/Movies:ro
      # Data persistence
      - chronarr_data:/app/data
      # Logs
      - chronarr_logs:/app/data/logs
      # Optional: Radarr SQLite database (read-only access)
      # Required if using RADARR_DB_TYPE=sqlite in config
      # - /path/to/radarr/config:/radarr-config:ro
      # Then set RADARR_DB_PATH=/radarr-config/radarr.db in .env
      # Optional: Sonarr SQLite database (read-only access)
      # Required if using SONARR_DB_TYPE=sqlite in config
      # - /path/to/sonarr/config:/sonarr-config:ro
      # Then set SONARR_DB_PATH=/sonarr-config/sonarr.db in .env
      # Optional: Emby plugin deployment
      # - /path/to/emby/plugins:/emby-plugins
    ports:
      - "${CORE_API_PORT:-8080}:8080"  # Core API (webhooks, processing)
    depends_on:
      chronarr-db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 60s
    networks:
      - chronarr-network

  # Chronarr Web Interface
  chronarr-web:
    image: sbcrumb/chronarr:latest  # Same image as core!
    container_name: chronarr-web
    restart: unless-stopped
    command: ["python", "start_web.py"]  # Different entry point
    env_file:
      - ./config/.env
      - ./config/.env.secrets
    environment:
      - TZ=${TZ:-UTC}
    volumes:
      # Config directory (shares with chronarr-core)
      - ./config:/config
    ports:
      - "${WEB_API_PORT:-8081}:8081"  # Web Interface
    depends_on:
      chronarr-db:
        condition: service_healthy
      chronarr:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 30s
      timeout: 15s
      retries: 3
      start_period: 30s
    networks:
      - chronarr-network

volumes:
  postgres_data:
    driver: local
  chronarr_data:
    driver: local
  chronarr_logs:
    driver: local

networks:
  chronarr-network:
    driver: bridge

# ========================================
# Quick Start Guide
# ========================================
#
# 1. First Run:
#    docker-compose up -d
#
#    This will:
#    - Create ./config/.env from .env.example
#    - Create ./config/.env.secrets from .env.secrets.example
#    - Start all containers
#
# 2. Configure:
#    nano ./config/.env
#    nano ./config/.env.secrets
#
#    Required settings:
#    - DB_PASSWORD (in .env.secrets)
#    - RADARR_URL, RADARR_API_KEY (optional)
#    - SONARR_URL, SONARR_API_KEY (optional)
#
# 3. Apply Configuration:
#    docker-compose restart
#
# 4. Access Web Interface:
#    http://your-server:8081
#
#    Then click Admin → Populate Database
#
# ========================================
# Configuration Notes
# ========================================
#
# Port Configuration:
# - Core API: ${CORE_API_PORT:-8080} (webhooks, processing)
# - Web Interface: ${WEB_API_PORT:-8081} (dashboard)
# - Database: ${DB_EXTERNAL_PORT:-5432} (optional external access)
#
# Media Path Configuration:
# - Update the volume mounts under chronarr: section
# - Example: - /your/movies:/media/Movies:ro
# - Example: - /your/tv:/media/TV:ro
#
# SQLite Database Access (for Radarr/Sonarr):
# - If using SQLite databases, you MUST mount them read-only
# - Radarr example:
#   1. Uncomment: - /path/to/radarr/config:/radarr-config:ro
#   2. Update path to your Radarr config directory
#   3. In ./config/.env set: RADARR_DB_TYPE=sqlite
#   4. In ./config/.env set: RADARR_DB_PATH=/radarr-config/radarr.db
# - Sonarr example:
#   1. Uncomment: - /path/to/sonarr/config:/sonarr-config:ro
#   2. Update path to your Sonarr config directory
#   3. In ./config/.env set: SONARR_DB_TYPE=sqlite
#   4. In ./config/.env set: SONARR_DB_PATH=/sonarr-config/sonarr.db
# - Common paths:
#   - Docker: /path/to/radarr/config (where radarr.db lives)
#   - Windows: C:/ProgramData/Radarr or C:/ProgramData/Sonarr
#   - Linux: /home/user/.config/Radarr or /var/lib/radarr
#
# Emby Plugin Deployment:
# - Uncomment the emby-plugins volume mount
# - Update path to your Emby plugins directory
# - Plugin auto-deploys on container start
#
# Performance Benefits:
# - Web interface operations don't impact core processing
# - Webhooks remain responsive during long scans
# - Independent scaling and resource allocation
# - Separated concerns for maintenance and updates
